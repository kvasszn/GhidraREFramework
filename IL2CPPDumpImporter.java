//Imports SDK dumps generated by REFramework and uses it to annotate the program.
//@author Fexty
//@category Annotation
//@keybinding
//@menupath
//@toolbar

import ghidra.app.script.GhidraScript;
import ghidra.app.services.DataTypeManagerService;
import ghidra.program.model.address.Address;
import ghidra.program.model.address.AddressFactory;
import ghidra.program.model.data.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.symbol.Namespace;
import ghidra.program.model.symbol.SourceType;
import ghidra.program.model.symbol.SymbolTable;
import ghidra.util.exception.CancelledException;

import org.json.*;

import java.io.BufferedWriter;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.stream.Collectors;

public class IL2CPPDumpImporter extends GhidraScript {

	static public FunctionManager functionManager;
	static public DataTypeManager typeManager;
	static public DataTypeManager builtinTypeManager;
	static public AddressFactory addressFactory;
	static public SymbolTable symbolTable;
	static public CategoryPath category = new CategoryPath("/IL2CPP_Types");
	static public HashMap<String, DataType> primitiveTypes;
	static public boolean makeShortGeneric = false;

	private int classesAdded;
	private int classesToAdd;
	private String classFilter;
	private BufferedWriter logWriter;


	private JSONObject il2cppDump;
	private HashMap<String, RETypeDefinition> typeMap;

	@Override
	protected void run() throws Exception {
		initialize();
		importIL2CPPDump();
	}

	private void initialize() throws Exception {
		// Fix for MHR Versions >= 16.0.0, which have ASLR enabled.
		var imageBase = askString("Image Base", "Enter the image base of the executable", "0x140000000");
		currentProgram.setImageBase(toAddr(imageBase), true);


		functionManager = currentProgram.getFunctionManager();
		builtinTypeManager = state.getTool().getService(DataTypeManagerService.class).getBuiltInDataTypesManager();
		addressFactory = currentProgram.getAddressFactory();
		symbolTable = currentProgram.getSymbolTable();
		typeMap = new HashMap<>();

		typeManager = currentProgram.getDataTypeManager();

		if (typeManager == null) {
			throw new Exception("failed to find typemanager");
		}

		try {
			var logFile = askFile("Select Log File", "Open");
			logWriter = Files.newBufferedWriter(logFile.toPath(), StandardCharsets.UTF_8);
		} catch (CancelledException e) {
			println("No log file selected. Logging exceptions to console.");
			logWriter = null;
		}

		final var uint8_t = typeManager.addDataType(
				new TypedefDataType("uint8_t", builtinTypeManager.getDataType("/uchar")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var int8_t = typeManager.addDataType(
				new TypedefDataType("int8_t", builtinTypeManager.getDataType("/char")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var uint16_t = typeManager.addDataType(
				new TypedefDataType("uint16_t", builtinTypeManager.getDataType("/ushort")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var int16_t = typeManager.addDataType(
				new TypedefDataType("int16_t", builtinTypeManager.getDataType("/short")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var uint32_t = typeManager.addDataType(
				new TypedefDataType("uint32_t", builtinTypeManager.getDataType("/uint")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var int32_t = typeManager.addDataType(
				new TypedefDataType("int32_t", builtinTypeManager.getDataType("/int")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var uint64_t = typeManager.addDataType(
				new TypedefDataType("uint64_t", builtinTypeManager.getDataType("/ulonglong")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var int64_t = typeManager.addDataType(
				new TypedefDataType("int64_t", builtinTypeManager.getDataType("/longlong")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var uintptr_t = typeManager.addDataType(
				new TypedefDataType("uintptr_t", builtinTypeManager.getDataType("/ulonglong")),
				DataTypeConflictHandler.REPLACE_HANDLER);
		final var intptr_t = typeManager.addDataType(
				new TypedefDataType("intptr_t", builtinTypeManager.getDataType("/ulonglong")),
				DataTypeConflictHandler.REPLACE_HANDLER);

		typeManager.addDataType(builtinTypeManager.getDataType("/void"), DataTypeConflictHandler.DEFAULT_HANDLER);
		typeManager.addDataType(new PointerDataType(typeManager.getDataType("/void")),
				DataTypeConflictHandler.DEFAULT_HANDLER);

		// Terminology:
		// - ValueType: A type that inherits (directly or indirectly) from System.ValueType or System.Enum
		// - Primitive Type: A ValueType with size <= sizeof(void*). Hardcoded here for simplicity.
		// - Reference Type: A type that is not a ValueType. All Reference Types are stored on the heap and are only accessed via pointers.
		primitiveTypes = new HashMap<>();
		primitiveTypes.put("System.Single", builtinTypeManager.getDataType("/float"));
		primitiveTypes.put("System.Double", builtinTypeManager.getDataType("/double"));
		primitiveTypes.put("System.Void", builtinTypeManager.getDataType("/void"));
		primitiveTypes.put("System.UInt8", uint8_t);
		primitiveTypes.put("System.UInt16", uint16_t);
		primitiveTypes.put("System.UInt32", uint32_t);
		primitiveTypes.put("System.UInt64", uint64_t);
		primitiveTypes.put("System.Int8", int8_t);
		primitiveTypes.put("System.Int16", int16_t);
		primitiveTypes.put("System.Int32", int32_t);
		primitiveTypes.put("System.Int64", int64_t);
		primitiveTypes.put("System.SByte", builtinTypeManager.getDataType("/byte"));
		primitiveTypes.put("System.Byte", builtinTypeManager.getDataType("/byte"));
		primitiveTypes.put("System.UByte", builtinTypeManager.getDataType("/uchar"));
		primitiveTypes.put("System.UIntPtr", uintptr_t);
		primitiveTypes.put("System.IntPtr", intptr_t);
		primitiveTypes.put("System.Char", builtinTypeManager.getDataType("/char"));
		primitiveTypes.put("System.UChar", builtinTypeManager.getDataType("/uchar"));
		primitiveTypes.put("System.Void*", typeManager.getDataType("/void *"));
		primitiveTypes.put("System.Boolean", builtinTypeManager.getDataType("/bool"));
		primitiveTypes.put("System.TypeCode", builtinTypeManager.getDataType("/int"));
		primitiveTypes.put("System.DateTime", uint64_t);
		primitiveTypes.put("System.TimeSpan", int64_t);
		primitiveTypes.put("s8", int8_t);
		primitiveTypes.put("u8", uint8_t);
		primitiveTypes.put("s16", int16_t);
		primitiveTypes.put("u16", uint16_t);
		primitiveTypes.put("s32", int32_t);
		primitiveTypes.put("u32", uint32_t);
		primitiveTypes.put("s64", int64_t);
		primitiveTypes.put("u64", uint64_t);
		primitiveTypes.put("via.Color", uint32_t);
	}

	private void importIL2CPPDump() throws Exception {
		boolean runDisassemble = false;

		if (!askYesNo("Close archive",
				"Do not forget to collapse the exe type archive or ghidra will freeze during a large import\nContinue ?")) {
			return;
		}

		if (askYesNo("Auto-Disassemble",
				"Do you want to automatically run the post import disassemble script after importing?")) {
			runDisassemble = true;
		}
		makeShortGeneric = askYesNo("Make Short Functions Generic?", "Some functions are generic and get used in multiple contexts with different types, this makes some shorter functions generic (sometimes it breaks things)");	


		File file = askFile("Select IL2CPP Dump", "Open");
		var reader = Files.newBufferedReader(file.toPath(), StandardCharsets.UTF_8);
		il2cppDump = new JSONObject(new JSONTokener(reader));
		reader.close();

		println("JSON Loaded");
		monitor.initialize(il2cppDump.length(), "Parsing IL2CPP Dump");

		int count = il2cppDump.length();
		int i = 0;
		for (var key : il2cppDump.keySet()) {
			typeMap.put(key, new RETypeDefinition(key, il2cppDump.getJSONObject(key)));
			println(String.format("parsed (%d/%d)", i++, count));
			monitor.incrementProgress(1);
		}

		println("JSON parsed");
		monitor.checkCancelled();
		il2cppDump.clear();
		System.gc();

		classFilter = askString("Filter", "Select Class Filter", "app");

		var keys = typeMap.keySet();
		if (classFilter == null || classFilter.isEmpty()) {
			classesToAdd = keys.size();

			// Add all types + Methods to ghidra
			for (var key : keys) {
				parseClass(key);
			}
		} else {
			Set<String> filtered = keys
					.stream()
					.filter((name) -> name.startsWith(classFilter))
					.collect(Collectors.toSet());
			classesToAdd = filtered.size();
			monitor.initialize(classesToAdd, "Importing IL2CPP Dump");

			for (var key : filtered) {
				parseClass(key);
			}
		}
		System.gc();

		if (runDisassemble) {
			runScript("PostImportDisassemble.java", state);
		}
	}

	public boolean isPrimitiveType(String name) {
		return primitiveTypes.containsKey(name);
	}

	public DataType getPrimitiveType(String objectName) {
		return primitiveTypes.get(objectName);
	}

	private DataType getValueTypeOrType(String name) {
		// Top-level types start with a '/', should only occur for built-in types.
		if (name.charAt(0) == '/') {
			var dt = typeManager.getDataType(name);
			if (dt == null) {
				println("Failed to find datatype:" + name);
			}
			return dt;
		}

		if (primitiveTypes.containsKey(name)) {
			return primitiveTypes.get(name);
		}

		// Type is not a ValueType
		RETypeDefinition type = typeMap.getOrDefault(name, null);
		if (type != null) {
			parseClass(name);
			var dt = typeMap.get(name).dataType;
			if (dt == null) {
				// Should only happen in case an Exception is thrown in parseClass
				println("dt is null for " + name + " after parsing");
			}

			return dt;
		}

		return null;
	}

	private DataType getPassingType(String name, boolean forField) {
		// Primitive types are always used in their value form and are never passed by
		// reference, unless a parameters explicitly has a ByRef/In/Out flag,
		// in which case the caller is responsible for handling that.
		if (isPrimitiveType(name)) {
			return getPrimitiveType(name);
		}

		DataType type = getValueTypeOrType(name);
		var typedef = typeMap.get(name);

		if (forField) {
			// ValueType and Enum fields are always stored in their value form, even if they are larger than 8 bytes.
			if (typedef != null && (typedef.isEnum || typedef.isValueType)) {
				return type;
			}
		} else {
			// If the type is a ValueType and its size is greater than 8 bytes, it is passed as a pointer.
			if (typedef != null && (typedef.isValueType || typedef.isEnum) && type.getLength() <= 8) {
				return type;
			}
		}

		if (typedef == null) {
			return type;
		}

		return typedef.pointerTo;
	}

	private boolean isReturnAsOutParameter(String name, DataType type) {
		var typedef = typeMap.get(name);
		return typedef != null && typedef.isValueType && type.getLength() > 8;
	}

	private DataType getPassingType(String name) {
		return getPassingType(name, false);
	}

	private Namespace getOrCreateNamespace(String name) {
		// Packed into a function because I hate java's enforced exception handling or
		// continued propagating.
		try {
			return symbolTable.getOrCreateNameSpace(currentProgram.getGlobalNamespace(), name, SourceType.IMPORTED);
		} catch (Exception e) {
			println("error getOrCreateNamespace:" + e.getMessage());
			return null;
		}
	}

	private void parseClass(String name) {
		if (!typeMap.containsKey(name)) {
			return;
		}

		RETypeDefinition definition = typeMap.get(name);
		if (definition.dataType != null) {
			return;
		}

		// Not actually an accurate display of progress if a filter is used but at least
		// gives me an idea of how much was already completed lol.
		println(String.format("(%d/%d) Parsing class %s", classesAdded, classesToAdd, name));
		classesAdded++;
		monitor.incrementProgress(1);
		if (!name.startsWith(classFilter)) {
			classesToAdd++;
			monitor.setMaximum(classesToAdd);
		}

		if (definition.isValueType && !definition.isEnum) {
			parseValueType(name, definition);
		} else {
			parseReferenceType(name, definition);
		}

		println(String.format("parsing %s done", name));
	}

	private void parseReferenceType(String name, RETypeDefinition definition) {
		// Create ghidra type from type definition
		DataType type = new StructureDataType(name, definition.size);

		// Enum types should be added as an actual enum, not a structure. They DO have a
		// structure representation however it is only very rarely used so I don't see
		// the point of adding that.
		// Also, this 'if' is inside the hasParent 'if' because enums always have
		// System.Enum as parent
		if (definition.isEnum) {
			var enumType = new EnumDataType(name, getPrimitiveType(definition.underlyingType).getLength());

			for (var field : definition.fields) {
				if (!field.isStatic()) {
					continue;
				}
				
				try {
					enumType.add(field.name, field.defaultValue);
				} catch (IllegalArgumentException e) {
					println(e.getMessage());
					println(e.getStackTrace()[0].toString());
				}

			}

			definition.size = enumType.getLength();

			// Overwrite ghidra type of type definition
			type = enumType;
		}

		// Register in archive before doing any new recursive parsing
		definition.dataType = typeManager.addDataType(type, DataTypeConflictHandler.REPLACE_HANDLER);
		definition.pointerTo = typeManager.addDataType(new PointerDataType(definition.dataType),
				DataTypeConflictHandler.REPLACE_HANDLER);

		// Parse parent class before parsing current class
		if (definition.hasParent()) {
			parseClass(definition.parent);
		}

		// Add all fields to the class
		if (definition.dataType instanceof Structure) {
			if (definition.name.endsWith("[]")) {
				addFieldsToArrayType(definition, (Structure) definition.dataType);
			} else {
				addFieldsOfClassToType(definition, (Structure) definition.dataType, false);
			}
		}

		// Add all methods
		if (!definition.methods.isEmpty()) {
			for (var method : definition.methods) {
				parseMethod(method, definition);
			}
		}
	}

	private void parseValueType(String name, RETypeDefinition definition) {
		var valueTypeSize = definition.size - typeMap.get("System.Object").size;
		if (valueTypeSize <= 0) {
			logError("Value type size is less than or equal to 0: " + name);
			
			// We still need to register the type so just parse it as a reference type
			parseReferenceType(name, definition);
			return;
		}

		// For value types we create both a structure for the value type itself and a
		// structure for its boxed form (i.e. when converted to a System.Object)
		DataType boxedType = new StructureDataType("Box<" + name + ">", definition.size);
		DataType valueType = new StructureDataType(name, definition.size - typeMap.get("System.Object").size);

		// Register in archive before doing any new recursive parsing
		definition.dataType = typeManager.addDataType(valueType, DataTypeConflictHandler.REPLACE_HANDLER);
		definition.pointerTo = typeManager.addDataType(new PointerDataType(definition.dataType),
				DataTypeConflictHandler.REPLACE_HANDLER);
			
		var boxedGhidraType = typeManager.addDataType(boxedType, DataTypeConflictHandler.REPLACE_HANDLER);
		typeManager.addDataType(new PointerDataType(boxedGhidraType), DataTypeConflictHandler.REPLACE_HANDLER);

		// Parse parent class before parsing current class
		if (definition.hasParent()) {
			parseClass(definition.parent);
		}

		// Add all fields to the class
		addFieldsOfClassToType(definition, (Structure) boxedGhidraType, false);
		addFieldsOfClassToType(definition, (Structure) definition.dataType, true);

		// Add all methods
		if (!definition.methods.isEmpty()) {
			for (var method : definition.methods) {
				parseMethod(method, definition);
			}
		}
	}

	private void handleStaticGetter(RETypeDefinition parent, REMethod method) {
		try {
			var fieldName = method.name.substring(4);
			var fieldType = getPassingType(method.returnType);

			disassemble(toAddr(method.address));
			var instruction = getInstructionAt(toAddr(method.address));
			if (instruction == null) {
				return;
			}

			if (!instruction.getMnemonicString().equals("MOV")) {
				return;
			}

			if (!instruction.getNext().getMnemonicString().equals("RET")) {
				return;
			}

			var addr = (Address) instruction.getOpObjects(1)[0];
			if (addr == null) {
				return;
			}

			createLabel(addr, fieldName, getOrCreateNamespace(parent.name), false, SourceType.IMPORTED);
			createData(addr, fieldType);
		} catch (Exception e) {
			// printf("Failed to parse static getter:  %s", e.getMessage());
			// println();
			logException("Failed to parse static getter: " + method.name, e);
		}
	}

	private void parseMethod(REMethod method, RETypeDefinition parent) {
		if (method.address == 0) {
			return;
		}

		if (method.flags.contains("Static") && method.name.startsWith("get_")) {
			handleStaticGetter(parent, method);
		}

		// If there are already symbols here, there are 2 possibilities:
		// 1. This is a generic function and we don't actually want to have a typed function, 
		// remove the function if it's there and add labels and a generic function to mark it's been acknowledged
		// 2. There is a symbol that was placed there automatically by ghidra (SourceType.DEFAULT),
		// in this case we can just overwrite it with our function.
		var address = addressFactory.getAddress(method.addressString);
		var symbol = getSymbolAt(address);


		if (symbol != null && symbol.getSource() != SourceType.DEFAULT) {
			try {
				Function existing = functionManager.getFunctionAt(address);
				if (existing != null && existing.getParentNamespace() != currentProgram.getGlobalNamespace()) {
					createLabel(address, existing.getName(), existing.getParentNamespace(), false,
							SourceType.USER_DEFINED);
					functionManager.removeFunction(address);
					var name = String.format("GenericFunction_%x", address.getOffset());
					if (existing.getName().equals(method.name)) {
						name = method.name;
					}
					createFunction(address, name);
				}

				createLabel(address, method.name, getOrCreateNamespace(parent.name), false,
						SourceType.USER_DEFINED);
			} catch (Exception e) {
				// println("error creating label for generic function: " + e.getMessage());
				logException("error creating label for generic function: " + method.name, e);
			}
			return;
		}

		Function function;

		// If the function does not yet exist then we try to create it and then rename it.
		try {
			// Idk what stupid bullshit i'm doing here but whatever it kinda works i think
			if (symbol != null && symbol.getSource() != SourceType.USER_DEFINED && symbol.getSource() != SourceType.IMPORTED) {
				symbol.delete();
				function = createFunction(address, method.name);
				var parentNamespace = getOrCreateNamespace(parent.name);
				function.setParentNamespace(parentNamespace);
			}
			if (symbol == null) {
				function = createFunction(address, method.name);
				var parentNamespace = getOrCreateNamespace(parent.name);
				function.setParentNamespace(parentNamespace);
			}
			createLabel(address, method.name, getOrCreateNamespace(parent.name), false, SourceType.IMPORTED);
			function = getFunctionAt(address);

			// if its a really small function, it's probably generic, so make a generic one instead
			int instructionCount = 0;
			InstructionIterator instructions = currentProgram.getListing().getInstructions(function.getBody(), true);

			boolean isShort = false;
			while (instructions.hasNext()) {
				Instruction instruction = instructions.next();
				instructionCount++;
				if (instruction.getMnemonicString().toLowerCase().contains("jmp")) {
					break;
				}
				if (instructionCount > 6) { 
					isShort = true;
					break; 
				}
			}
			if (isShort) {
				try {
					function.getSymbol().delete();
					functionManager.removeFunction(address);
					var name = String.format("GenericFunction_%x", address.getOffset());
					createFunction(address, name);
				} catch (Exception e) {
					logException("error creating label for generic function: " + method.name, e);
				}
				return;
			}
		} catch (Exception e) {
			logException("error creating function: " + method.name + ", parent: " + parent.name, e);
			return;
		}

		// Add all parameters to the function. Code is not complete because there are a
		// million exceptions to consider where certain parameters do not exist or
		// others exist even tho the dump does not specify them.
		// As a general rule tho:
		// - The engine conforms to the x64 calling convention so parameters are RCX,
		// RDX, R8, R9, Stack...
		// - (Basically) all methods take a thread context as their first argument in
		// RCX (or RDX, exception below)
		// - If a method has the 'HasThis' flag, then it takes a 'this' parameter in RDX
		// (or R8, ...)
		// - All parameters listed by the dump follow after these 2 in R8/R9 and then on
		// the stack starting at 0x28
		// - The size of an argument on the stack is at most 8 bytes. Types with size
		// greater 8 are passed as a
		// pointer.
		// - Stack arguments are always 8 byte aligned regardless of the size of the
		// type. So +0x28, +0x30, +0x38...
		// - If a function has a return type which is a ValueType and its size is
		// greater than sizeof(void*) then
		// this parameter is passed as a pointer in RCX *always*. It is also returned as
		// a pointer
		// I believe there are also some types that aren't explicitly ValueTypes but
		// still adhere to this behavior.
		// - There might be some more intricacies that I have missed...
		var params = method.parameters;
		var funcParams = new ArrayList<ParameterImpl>();

		try {
			// Get the return type
			var retType = getPassingType(method.returnType);

			if (isReturnAsOutParameter(method.returnType, retType)) {
				funcParams.add(new ParameterImpl("ret", retType, currentProgram));
			}

			var ret = new ReturnParameterImpl(retType, currentProgram);

			// Methods always take the thread context as their first parameter
			funcParams.add(new ParameterImpl("vmctx", getValueTypeOrType("/void *"), currentProgram));

			if (method.implFlags.contains("HasThis")) {
				funcParams.add(new ParameterImpl("this", parent.dataType, currentProgram));
			}

			for (var param : params) {
				funcParams.add(new ParameterImpl(param.name, getValueTypeOrType(param.type), currentProgram));
			}

			// Using this function because Function.addParameter is deprecated. This also makes
			// things easier as ghidra tries to determine Register and stack offset by itself.
			function.updateFunction("__fastcall", ret, funcParams, Function.FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
		} catch (Exception e) {
			// println("error parsing function signature:" + e.getMessage());
			logException("error parsing function signature for " + parent.name + "." + method.name, e);
		}
	}

	private void addFieldsToArrayType(RETypeDefinition definition, Structure type) {
		type.deleteAll();
		type.growStructure(0x20);

		type.replaceAtOffset(0x0, getValueTypeOrType("/void *"), 8, "object_info", "");
		type.replaceAtOffset(0x8, getPrimitiveType("System.Int32"), 4, "ref_count", "");
		type.replaceAtOffset(0x10, getValueTypeOrType("/void *"), 8, "contained_type", "");
		type.replaceAtOffset(0x18, getPrimitiveType("System.Int32"), 4, "_n", "");
		type.replaceAtOffset(0x1C, getPrimitiveType("System.Int32"), 4, "Count", "");

		String containedType = definition.name.replace("[]", "");
		var containedDataType = getPassingType(containedType, true);
		if (containedDataType == null) {
			containedDataType = getValueTypeOrType("/void *");
		}
		type.growStructure(containedDataType.getLength());
		type.replaceAtOffset(0x20,
				new ArrayDataType(containedDataType, 1, containedDataType.getLength()),
				containedDataType.getLength(), "Elements", "");
	}

	private void addFieldsOfClassToType(RETypeDefinition definition, Structure type, boolean isValueType) {
		if (definition == null) {
			return;
		}

		if (definition.size == 0) {
			return;
		}
		type.setDescription(String.format("%s:0x%x -> ", definition.name, definition.size) + type.getDescription());
		if (definition.hasFields()) {
			try {
				addFieldsToType(definition.fields, type, isValueType);
				if (definition.hasParent()) {
					addFieldsOfClassToType(typeMap.get(definition.parent), type, isValueType);
				}
			} catch (Exception e) {
				logException("error adding fields to type: " + definition.name, e);
			}

		}
	}

	private void addFieldsToType(ArrayList<REField> fields, Structure type, boolean isValueType) throws Exception {
		for (var field : fields) {
			if (!field.isStatic()) {
				String typeName = field.type;

				RETypeDefinition fieldType = typeMap.getOrDefault(typeName, null);
				if (fieldType == null) {
					continue;
				}

				var fieldDataType = getPassingType(typeName, true);
				type.replaceAtOffset(
					isValueType ? field.offsetFromFieldPtr : field.offsetFromBase,
					fieldDataType, 
					fieldDataType.getLength(), 
					field.name,
					field.flags
				);
			}
		}
	}

	private void logError(String message) {
		if (logWriter == null) {
			println("Encountered Error: ");
			println(message);
			return;
		}

		try {
			logWriter.write("Encountered Error: ");
			logWriter.newLine();
			logWriter.write(message);
			logWriter.newLine();
		} catch (Exception e) {
			println("error writing to log file: " + e.getMessage());
		}
	}

	private void logException(String message, Exception e) {
		if (logWriter == null) {
			println("Encountered Exception: ");
			println(message);
			println(e.getMessage());
			for (StackTraceElement element : e.getStackTrace()) {
				println(element.toString());
			}
			return;
		}

		try {
			logWriter.write("Encountered Exception: ");
			logWriter.newLine();
			logWriter.write(message);
			logWriter.newLine();
			logWriter.write(e.getMessage());
			logWriter.newLine();
			for (StackTraceElement element : e.getStackTrace()) {
				logWriter.write(element.toString());
				logWriter.newLine();
			}
			logWriter.newLine();
		} catch (Exception ex) {
			println("error writing to log file: " + ex.getMessage());
		}
	}

	private static class REMethod {
		public static class Parameter {
			public String name;
			public String type;

			public Parameter(String n, String t) {
				name = n;
				type = t;
			}
		}

		public String name;
		public String flags;
		public long address;
		public String addressString;
		public int id;
		public int invokeId;
		public String implFlags;
		public ArrayList<Parameter> parameters;
		public String returnType;

		REMethod(String name, JSONObject method) {
			flags = method.has("flags") ? method.getString("flags") : "";
			addressString = method.getString("function");
			address = Long.parseLong(addressString, 16);
			id = method.getInt("id");
			invokeId = method.getInt("invoke_id");
			if (method.has("impl_flags")) {
				implFlags = method.getString("impl_flags");
			} else {
				implFlags = "";
			}

			// Since method names are stored with [Name][ID] we remove the ID to avoid
			// confusing names in ghidra.
			// Also constructor names always start with a '.' so we remove that also to
			// avoid 'Namespace::.Name'
			this.name = (name.startsWith(".") ? name.substring(1) : name).substring(0,
					name.indexOf(Integer.toString(id)));

			parameters = new ArrayList<>();
			if (method.has("params")) {
				var params = method.getJSONArray("params");
				for (int i = 0; i < params.length(); i++) {
					var param = params.getJSONObject(i);
					parameters.add(new Parameter(param.getString("name"), param.getString("type")));
				}
			}

			returnType = method.getJSONObject("returns").getString("type");
		}
	}

	private static class REField {
		public String flags;
		public int id;
		public int offsetFromBase;
		public int offsetFromFieldPtr;
		public String type;
		public String name;
		public int defaultValue;

		public REField(String name, JSONObject field) {
			flags = field.has("flags") ? field.getString("flags") : "";
			id = field.getInt("id");
			offsetFromBase = Integer.parseInt(field.getString("offset_from_base").substring(2), 16);

			// Only ever used for ValueTypes, can ignore for the most part. Kept it here for
			// completeness' sake.
			offsetFromFieldPtr = Integer.parseInt(field.getString("offset_from_fieldptr").substring(2), 16);
			type = field.getString("type");

			// Only really used for enum members
			defaultValue = field.optInt("default", 0);

			this.name = name;
			if (this.name.matches("<(.+)>k__BackingField")) {
				this.name = "__" + this.name.substring(1, this.name.length() - 16);
				this.flags += " | BackingField";
			}
		}

		public boolean isStatic() {
			return flags.contains("Static");
		}
	}

	private static class RETypeDefinition {
		public String name;
		public int size;
		public String parent;
		public ArrayList<REField> fields;
		public ArrayList<REMethod> methods;
		public boolean isValueType;
		public boolean isEnum;
		public String underlyingType;

		public DataType dataType;
		public DataType pointerTo;

		public RETypeDefinition(String className, JSONObject object) {
			name = className;
			if (object.has("size"))
				size = Integer.parseInt(object.getString("size"), 16);
			parent = object.has("parent") ? object.getString("parent") : "";
			fields = new ArrayList<>();
			methods = new ArrayList<>();

			if (parent.equals("System.ValueType")) {
				isValueType = true;
				isEnum = false;
			} else if (parent.equals("System.Enum")) {
				isValueType = false;
				isEnum = true;
			} else {
				isValueType = false;
				isEnum = false;
			}

			if (isEnum) {
				// Get the enums underlying type
				if (object.has("reflection_properties")) {
					underlyingType = object.getJSONObject("reflection_properties").getJSONObject("value__")
							.getString("type");
				} else {
					underlyingType = object.getJSONObject("fields").getJSONObject("value__").getString("type");
				}
			} else {
				underlyingType = "";
			}

			if (object.has("fields")) {
				var classFields = object.getJSONObject("fields");
				for (var fieldName : classFields.keySet()) {
					fields.add(new REField(fieldName, classFields.getJSONObject(fieldName)));
				}
			}

			if (object.has("methods")) {
				var classMethods = object.getJSONObject("methods");
				for (var methodName : classMethods.keySet()) {
					REMethod method = new REMethod(methodName, classMethods.getJSONObject(methodName));
					methods.add(method);
				}
			}
		}

		public boolean hasFields() {
			return !fields.isEmpty();
		}

		public boolean hasParent() {
			return !parent.isEmpty();
		}
	}
}

